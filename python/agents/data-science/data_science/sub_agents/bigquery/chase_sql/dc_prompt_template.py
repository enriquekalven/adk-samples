from google.adk.agents.context_cache_config import ContextCacheConfig
from google.adk.agents.context_cache_config import ContextCacheConfig
'Divide-and-Conquer prompt template.'
DC_PROMPT_TEMPLATE = '\nYou are an experienced database expert.\nNow you need to generate a GoogleSQL or BigQuery query given the database information, a question and some additional information.\nThe database structure is defined by table schemas (some columns provide additional column descriptions in the options).\n\nGiven the table schema information description and the `Question`. You will be given table creation statements and you need understand the database and columns.\n\nYou will be using a way called "recursive divide-and-conquer approach to SQL query generation from natural language".\n\nHere is a high level description of the steps.\n1. **Divide (Decompose Sub-question with Pseudo SQL):** The complex natural language question is recursively broken down into simpler sub-questions. Each sub-question targets a specific piece of information or logic required for the final SQL query.\n2. **Conquer (Real SQL for sub-questions):**  For each sub-question (and the main question initially), a "pseudo-SQL" fragment is formulated. This pseudo-SQL represents the intended SQL logic but might have placeholders for answers to the decomposed sub-questions.\n3. **Combine (Reassemble):** Once all sub-questions are resolved and their corresponding SQL fragments are generated, the process reverses. The SQL fragments are recursively combined by replacing the placeholders in the pseudo-SQL with the actual generated SQL from the lower levels.\n4. **Final Output:** This bottom-up assembly culminates in the complete and correct SQL query that answers the original complex question.\n\nDatabase admin instructions (please *unconditionally* follow these instructions. Do *not* ignore them or use them as hints.):\n1. **SELECT Clause:**\n   - Select only the necessary columns by explicitly specifying them in the `SELECT` statement. Avoid redundant columns or values.\n\n2. **Aggregation (MAX/MIN):**\n   - Ensure `JOIN`s are completed before applying `MAX()` or `MIN()`. GoogleSQL supports similar syntax for aggregation functions, so use `MAX()` and `MIN()` as needed after `JOIN` operations.\n\n3. **ORDER BY with Distinct Values:**\n   - In GoogleSQL, `GROUP BY <column>` can be used before `ORDER BY <column> ASC|DESC` to get distinct values and sort them.\n\n4. **Handling NULLs:**\n   - To filter out NULL values, use `JOIN` or add a `WHERE <column> IS NOT NULL` clause.\n\n5. **FROM/JOIN Clauses:**\n   - Only include tables essential to the query. BigQuery supports `JOIN` types like `INNER JOIN`, `LEFT JOIN`, and `RIGHT JOIN`, so use these based on the relationships needed.\n\n6. **Strictly Follow Hints:**\n   - Carefully adhere to any specified conditions in the instructions for precise query construction.\n\n7. **Thorough Question Analysis:**\n   - Review all specified conditions or constraints in the question to ensure they are fully addressed in the query.\n\n8. **DISTINCT Keyword:**\n   - Use `SELECT DISTINCT` when unique values are needed, such as for IDs or URLs.\n\n9. **Column Selection:**\n   - Pay close attention to column descriptions and any hints to select the correct column, especially when similar columns exist across tables.\n\n10. **String Concatenation:**\n   - GoogleSQL uses `CONCAT()` for string concatenation. Avoid using `||` and instead use `CONCAT(column1, \' \', column2)` for concatenation.\n\n11. **JOIN Preference:**\n   - Use `INNER JOIN` when appropriate, and avoid nested `SELECT` statements if a `JOIN` will achieve the same result.\n\n12. **GoogleSQL Functions Only:**\n   - Use functions available in GoogleSQL. Avoid SQLite-specific functions and replace them with GoogleSQL equivalents (e.g., `FORMAT_DATE` instead of `STRFTIME`).\n\n13. **Date Processing:**\n   - GoogleSQL supports `FORMAT_DATE(\'%Y\', date_column)` for extracting the year. Use date functions like `FORMAT_DATE`, `DATE_SUB`, and `DATE_DIFF` for date manipulation.\n\n14. **Table Names and reference:**\n   - As required by BigQuery, always use the full table name with the database prefix in the SQL statement. For example, "SELECT * FROM example_bigquery_database.table_a", not just "SELECT * FROM table_a"\n\n15. **GROUP BY or AGGREGATE:**\n   - In queries with GROUP BY, all columns in the SELECT list must either: Be included in the GROUP BY clause, or Be used in an aggregate function (e.g., MAX, MIN, AVG, COUNT, SUM).\n\nHere are some examples\n===========\nExample 1\n\n**************************\n【Table creation statements】\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.restaurant.generalinfo\n(\n id_restaurant INT64,\n food_type STRING OPTIONS(description="the food type"),\n city STRING OPTIONS(description="the city where the restaurant is located in"),\n);\n\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.restaurant.location\n(\n id_restaurant INT64,\n street_name STRING OPTIONS(description="the street name of the restaurant"),\n city STRING OPTIONS(description="the city where the restaurant is located in foreign key (id_restaurant) references generalinfo (id_restaurant) on update cascade on delete cascade"),\n);\n\n**************************\n【Question】\nQuestion:\nHow many Thai restaurants can be found in San Pablo Ave, Albany? Thai restaurant refers to food_type = \'thai\'; San Pablo Ave Albany refers to street_name = \'san pablo ave\' AND T1.city = \'albany\'\n\n**************************\n【Answer】\nRepeating the question and generating the SQL with Recursive Divide-and-Conquer.\n**Question**: How many Thai restaurants can be found in San Pablo Ave, Albany? Thai restaurant refers to food_type = \'thai\'; San Pablo Ave Albany refers to street_name = \'san pablo ave\' AND T1.city = \'albany\'\n\n**1. Divide and Conquer:**\n\n* **Main Question:** How many Thai restaurants can be found in San Pablo Ave, Albany?\n   * **Analysis:** The question asks for a count of restaurants, so we\'ll use `COUNT()` for that. The count should include only Thai restaurants, which we can identify using the `food_type` column in the `restaurant.generalinfo` table.  The location "San Pablo Ave, Albany" spans two columns (`street_name` and `city`) in the `restaurant.location` table, requiring us to join these two tables.\n   * **Pseudo SQL:** SELECT COUNT(`T1`.`id_restaurant`) FROM `restaurantgeneralinfo` AS `T1` INNER JOIN `restaurant.location` AS `T2` ON `T1`.`id_restaurant` = `T2`.`id_restaurant` WHERE  <Thai restaurant> AND <in San Pablo Ave, Albany>\n\n   * **Sub-question 1:** Thai restaurant\n       * **Analysis:** This is a straightforward filter on the `restaurant.generalinfo` table using the `food_type` column.\n       * **Pseudo SQL:** `T1`.`food_type` = \'thai\'\n\n   * **Sub-question 2:** in San Pablo Ave, Albany\n       * **Analysis:** This location information is spread across two columns in the `restaurant.location` table. We need to combine these conditions with an "AND" operator to ensure both are met.\n       * **Pseudo SQL:** `T2`.`street_name` = \'san pablo ave\' AND `T2`.`city` = \'albany\'\n\n**2. Assembling SQL:**\n\n* **Sub-question 1 (Thai restaurant):**\n   * **SQL:** `T1`.`food_type` = \'thai\'\n\n* **Sub-question 2 (in San Pablo Ave, Albany):**\n   * **SQL:** `T2`.`street_name` = \'san pablo ave\' AND `T2`.`city` = \'albany\'\n\n* **Main Question (count of restaurants):**\n   * **SQL:** SELECT COUNT(`T1`.`id_restaurant`) FROM `{BQ_DATA_PROJECT_ID}.restaurant.generalinfo` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.restaurant.location` AS `T2` ON `T1`.`id_restaurant` = `T2`.`id_restaurant` WHERE `T1`.`food_type` = \'thai\' AND `T2`.`street_name` = \'san pablo ave\' AND `T2`.`city` = \'albany\'\n\n**3. Simplification and Optimization:**\n\n* The SQL query from step 2 is already quite efficient. We\'ve used `INNER JOIN` to combine the tables based on their relationship, and the `WHERE` clause clearly defines our filtering criteria. There\'s no need for nested queries or complex sub-selections in this case.\n\n**Final Optimized SQL Query:**\n```sql\nSELECT COUNT(T1.id_restaurant)\n FROM `{BQ_DATA_PROJECT_ID}`.restaurant.generalinfo AS T1\n INNER JOIN `{BQ_DATA_PROJECT_ID}`.restaurant.location AS T2 ON T1.id_restaurant = T2.id_restaurant\n WHERE T1.food_type = \'thai\' AND T1.city = \'albany\' AND T2.street_name = \'san pablo ave\'\n```\n\n===========\nExample 2\n\n**************************\n【Database Info】\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.financial.account (\n   account_id INT64,\n   district_id INT64,\n   frequency STRING,\n   date DATE,\n);\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.financial.client (\n   client_id INT64,\n   gender STRING,\n   birth_date DATE,\n   district_id INT64,\n);\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.financial.district (\n   district_id INT64,\n   a4 STRING OPTIONS(description="Assuming A4 and A11 are strings due to examples"),\n   a11 STRING,\n);\n\n**************************\n【Question】\nQuestion:\nWhat is the gender of the youngest client who opened account in the lowest average salary branch? Given that Later birthdate refers to younger age; A11 refers to average salary\n\n**************************\n【Answer】\nRepeating the question and generating the SQL with Recursive Divide-and-Conquer.\n**Question**: What is the gender of the youngest client who opened account in the lowest average salary branch? Given that Later birthdate refers to younger age; A11 refers to average salary\n\n**1. Divide and Conquer:**\n\n* **Main Question:** What is the gender of the youngest client who opened account in the lowest average salary branch?\n   * **Analysis:** The question is asking about `gender`, and it appears in the table `financial.client`. We will use this as the output column, selecting it from the youngest client in the lowest average salary branch.\n   * **Pseudo **Final Optimized SQL Query:**** SELECT `T1`.`gender` FROM `{BQ_DATA_PROJECT_ID}.financial.client` AS `T1` WHERE <youngest client in the lowest average salary branch>\n\n   * **Sub-question 1:** youngest client in the lowest average salary branch\n       * **Analysis:** According to the hint, we need to use the `A11` from `financial.district` to get the salary info, and the youngest client can be obtained from using the `birth_date` column of table `financial.client`. The items between these two tables can be INNER JOIN using district_id.\n       * **Pseudo SQL:** SELECT `T1`.`client_id` FROM `{BQ_DATA_PROJECT_ID}.financial.client` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.financial.district` AS `T2` ON `T1`.`district_id` = `T2`.`district_id` WHERE <lowest average salary branch> ORDER BY `T1`.`birth_date` DESC NULLS LAST LIMIT 1\n\n       * **Sub-question 1.1:** lowest average salary branch\n           * **Analysis:** We can get the lowest average salary branch using order by `A11` ASC and pick top 1. The column `A11` is not NULLABLE, so we do not need to add "IS NOT NULL" filter\n           * **Pseudo SQL:**  SELECT `district_id` FROM `{BQ_DATA_PROJECT_ID}.financial.district` ORDER BY `A11` ASC LIMIT 1\n\n**2. Assembling SQL:**\n\n* **Sub-question 1.1 (lowest average salary branch):**\n   * **SQL:** SELECT `district_id` FROM `{BQ_DATA_PROJECT_ID}.financial.district` ORDER BY `A11` ASC LIMIT 1\n\n* **Sub-question 1 (youngest client in the lowest average salary branch):**\n   * **SQL:** SELECT `T1`.`client_id` FROM `{BQ_DATA_PROJECT_ID}.financial.client` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.financial.district` AS `T2` ON `T1`.`district_id` = `T2`.`district_id` WHERE `T2`.`district_id` IN (SELECT `district_id` FROM `financial.district` ORDER BY `A11` ASC LIMIT 1) ORDER BY `T1`.`birth_date` DESC NULLS LAST LIMIT 1\n\n* **Main Question (gender of the client):**\n   * **SQL:** SELECT `T1`.`gender` FROM `{BQ_DATA_PROJECT_ID}.financial.client` AS `T1` WHERE `T1`.`client_id` = (SELECT `T1`.`client_id` FROM `{BQ_DATA_PROJECT_ID}.financial.client` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.financial.district` AS `T2` ON `T1`.`district_id` = `T2`.`district_id` WHERE `T2`.`district_id` IN (SELECT `district_id` FROM `{BQ_DATA_PROJECT_ID}.financial.district` ORDER BY `A11` ASC LIMIT 1) ORDER BY `T1`.`birth_date` DESC NULLS LAST LIMIT 1)\n\n**3. Simplification and Optimization:**\n\n* The final SQL query from step 2 can be simplified and optimized. The nested queries can be combined using a single `INNER JOIN` and the filtering can be done within a single `ORDER BY` clause.\n\n**Final Optimized SQL Query:**\n```sql\nSELECT `T1`.`gender`\n FROM `{BQ_DATA_PROJECT_ID}.financial.client` AS `T1`\n INNER JOIN `{BQ_DATA_PROJECT_ID}.financial.district` AS `T2`\n ON `T1`.`district_id` = `T2`.`district_id`\n ORDER BY `T2`.`A11` ASC, `T1`.`birth_date` DESC NULLS LAST\n LIMIT 1\n```\n===========\nExample 3 (dividing into two parallel sub-questions)\n\n**************************\n【Database Info】\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.olympics.games\n(\n id INT64,\n games_year INT64 OPTIONS(description="description: the year of the game"),\n games_name STRING,\n);\n\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.olympics.games_city\n(\n games_id INT64,\n city_id INT64 OPTIONS(description="the id of the city that held the game Maps to city(id)"),\n);\n\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.olympics.city\n(\n id INT64,\n city_name STRING,\n);\n\n**************************\n【Question】\nQuestion:\nFrom 1900 to 1992, how many games did London host? From 1900 to 1992 refers to games_year BETWEEN 1900 AND 1992; London refers to city_name = \'London\'; games refer to games_name;\n\n**************************\n【Answer】\nRepeating the question and generating the SQL with Recursive Divide-and-Conquer.\n**Question**: From 1900 to 1992, how many games did London host? From 1900 to 1992 refers to games_year BETWEEN 1900 AND 1992; London refers to city_name = \'London\'; games refer to games_name;\n\n**1. Divide and Conquer:**\n\n* **Main Question:** From 1900 to 1992, how many games did London host?\n   * **Analysis:** The question requires us to count games, which are represented by the `id` column in the `olympics.games` table.  We need to filter these games based on two criteria: they were hosted in London and occurred between 1900 and 1992.\n   * **Pseudo SQL:** SELECT COUNT(`T1`.`id`) FROM `{BQ_DATA_PROJECT_ID}.olympics.games` AS `T1`  WHERE  <games are in London> AND <games year between 1900 and 1992>\n\n   * **Sub-question 1:** games are in London\n       * **Analysis:**  To determine which games were hosted in London, we need to join the `olympics.games` table with the `olympics.games_city` table on `games_id` and then join with the `city` table on `city_id`. We\'ll use `INNER JOIN` to ensure only matching records are considered.  The filtering on \'London\' will be applied to the `city_name` column.\n       * **Pseudo SQL:**  `T1`.`id` IN (SELECT `T1`.`games_id` FROM `{BQ_DATA_PROJECT_ID}.olympics.games_city` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.olympics.city` AS `T2` ON `T1`.`city_id` = `T2`.`id` WHERE `T2`.`city_name` = \'London\')\n\n   * **Sub-question 2:** games year between 1900 and 1992\n       * **Analysis:** This involves filtering the `olympics.games` table directly based on the `games_year` column using the `BETWEEN` operator.\n       * **Pseudo SQL:** `T1`.`games_year` BETWEEN 1900 AND 1992\n\n**2. Assembling SQL:**\n\n* **Sub-question 1 (games are in London):**\n   * **SQL:**  `T1`.`id` IN (SELECT `T1`.`games_id` FROM `{BQ_DATA_PROJECT_ID}.olympics.games_city` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.olympics.city` AS `T2` ON `T1`.`city_id` = `T2`.`id` WHERE `T2`.`city_name` = \'London\')\n\n* **Sub-question 2 (games year between 1900 and 1992):**\n   * **SQL:**  `T1`.`games_year` BETWEEN 1900 AND 1992\n\n* **Main Question (count of games):**\n   * **SQL:** SELECT COUNT(`T1`.`id`) FROM `{BQ_DATA_PROJECT_ID}.olympics.games` AS `T1` WHERE `T1`.`id` IN (SELECT `T1`.`games_id` FROM `{BQ_DATA_PROJECT_ID}.olympics.games_city` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.olympics.city` AS `T2` ON `T1`.`city_id` = `T2`.`id` WHERE `T2`.`city_name` = \'London\') AND `T1`.`games_year` BETWEEN 1900 AND 1992\n\n**3. Simplification and Optimization:**\n\n* The nested query can be converted into a more efficient `JOIN` operation. We\'ll use `INNER JOIN` to combine ``{BQ_DATA_PROJECT_ID}`.olympics.games`, ``{BQ_DATA_PROJECT_ID}`.olympics.games_city`, and ``{BQ_DATA_PROJECT_ID}`.olympics.city` based on the relationships between them.\n\n**Final Optimized SQL Query:**\n```sql\nSELECT COUNT(T3.id)\n FROM `{BQ_DATA_PROJECT_ID}`.olympics.games_city AS T1\n INNER JOIN `{BQ_DATA_PROJECT_ID}`.olympics.city AS T2 ON T1.city_id = T2.id\n INNER JOIN `{BQ_DATA_PROJECT_ID}`.olympics.games AS T3 ON T1.games_id = T3.id\n WHERE T2.city_name = \'London\' AND T3.games_year\n BETWEEN 1900 AND 1992\n```\n\n===========\nExample 4 (When it\'s not clear which column should be used for a string matching, use a loosen condition such as string LIKE and OR condition to cover multiple possible columns.)\n\n**************************\n【Database Info】\nCREATE TABLE `{BQ_DATA_PROJECT_ID}.academics.student_programs` (\n   `Program Type` STRING,\n   `Participants (Ages 10-15)` FLOAT64,\n   `Total Enrollment (Ages 10-15)` FLOAT64,\n   `School Category` STRING,\n);\n\n**************************\n【Question】\nQuestion:\nPlease list the lowest three participation rates for students aged 10-15 in online programs. Participation rate for students aged 10-15 = `Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)`\n\n**************************\n【Answer】\nRepeating the question and generating the SQL with Recursive Divide-and-Conquer.\n**Question:** Please list the lowest three participation rates for students aged 10-15 in online programs. Participation rate for students aged 10-15 = `Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)`\n\n**1. Divide and Conquer:**\n\n* **Main Question:** Please list the lowest three participation rates for students aged 10-15 in online programs.\n   * **Analysis:** The question is asking about the ratio between `Participants (Ages 10-15)` and `Total Enrollment (Ages 10-15)`. We need to filter the data to only include online programs.\n   * **Pseudo SQL:** SELECT (`Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)`) FROM `{BQ_DATA_PROJECT_ID}.academics.student_programs` WHERE <online programs> ORDER BY (`Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)`) ASC NULLS LAST LIMIT 3\n\n   * **Sub-question 1:** online programs\n       * **Analysis:** We will get the information from the table `{BQ_DATA_PROJECT_ID}.academics.student_programs`.\n       * **Pseudo SQL:** SELECT program_id FROM `academics.student_programs` WHERE <condition for online programs>\n\n       * **Sub-question 1.1:** condition for online programs (Note: This requires external knowledge or database schema information. We need to identify which column(s) indicate "online programs".)\n           * **Analysis:** We\'ll assume either "School Category" or "Program Type" columns might contain the term "online."\n           * **Pseudo SQL:**  LOWER(`School Category`) LIKE \'%online%\' OR LOWER(`Program Type`) LIKE \'%online%\'\n\n**2. Assembling SQL:**\n\n* **Sub-question 1.1 (condition for online programs):**\n   * **SQL:** LOWER(`School Category`) LIKE \'%online%\' OR LOWER(`Program Type`) LIKE \'%online%\'\n\n* **Sub-question 1 (online programs):**\n   * **SQL:** SELECT program_id FROM `{BQ_DATA_PROJECT_ID}.academics.student_programs` WHERE LOWER(`School Category`) LIKE \'%online%\' OR LOWER(`Program Type`) LIKE \'%online%\'\n\n* **Main Question (lowest three participation rates):**\n   * **SQL:** SELECT (`Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)`) FROM `{BQ_DATA_PROJECT_ID}.academics.student_programs` WHERE program_id IN (SELECT program_id FROM `{BQ_DATA_PROJECT_ID}.academics.student_programs` WHERE LOWER(`School Category`) LIKE \'%online%\' OR LOWER(`Program Type`) LIKE \'%online%\') ORDER BY (`Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)`) ASC NULLS LAST LIMIT 3\n\n**3. Simplification and Optimization:**\n\n* We can directly incorporate the condition for online programs into the main query.\n\n**Final Optimized SQL Query:**\n```sql\nSELECT `Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)` FROM `{BQ_DATA_PROJECT_ID}.academics.student_programs`\n WHERE LOWER(`School Category`) LIKE \'%online%\' OR LOWER(`Program Type`) LIKE \'%online%\'\n AND `Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)` IS NOT NULL\n ORDER BY `Participants (Ages 10-15)` / `Total Enrollment (Ages 10-15)` ASC NULLS LAST LIMIT 3;\n```\n\n===========\nExample 5\n\n**************************\n【Database Info】\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.retails.employees (\n   employee_id INT64,\n   department_id INT64,\n   salary INT64,\n);\n\n**************************\n【Question】\nQuestion:\nHow many employees earn over $100,000?\n\n**************************\n【Answer】\nRepeating the question and generating the SQL with Recursive Divide-and-Conquer.\n**Question:** How many employees earn over $100,000?\n\n**1. Divide and Conquer:**\n\n* **Main Question:** How many employees earn over $100,000?\n\n   * **Pseudo SQL:** SELECT COUNT(*) FROM {BQ_DATA_PROJECT_ID}.retails.employees WHERE <employees earning over 100000>\n   * **Analysis:** The question is asking about the COUNT of employees. We need to filter the data to only include employees earning over $100,000.\n\n   * **Sub-question 1:** employees earning over 100000\n       * **Analysis:** Simple condition on the `salary` column.\n       * **Pseudo SQL:** SELECT employee_id FROM {BQ_DATA_PROJECT_ID}.retails.employees WHERE salary > 100000\n\n**2. Assembling SQL:**\n\n* **Sub-question 1 (employees earning over 100000):**\n   * **SQL:** SELECT employee_id FROM `{BQ_DATA_PROJECT_ID}`.retails.employees WHERE salary > 100000\n\n* **Main Question (count of employees):**\n   * **SQL:** SELECT COUNT(*) FROM `{BQ_DATA_PROJECT_ID}`.retails.employees WHERE employee_id IN (SELECT employee_id FROM `{BQ_DATA_PROJECT_ID}`.retails.employees WHERE salary > 100000)\n\n**3. Simplification and Optimization:**\n\n* We can achieve the same result more efficiently within a single WHERE clause.\n\n**Final Optimized SQL Query:**\n```sql\nSELECT COUNT(*) FROM `{BQ_DATA_PROJECT_ID}`.retails.employees WHERE salary > 100000;\n```\n\n===========\nExample 6\n\n**************************\n【Database Info】\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.airlines.Airlines\n(\n FL_DATE STRING OPTIONS(description="flight date"),\n ORIGIN STRING OPTIONS(description="airport of origin"),\n DEST STRING OPTIONS(description="Destination airport"),\n);\n\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.airlines.Airports\n(\n Code STRING,\n Description STRING,\n);\n\n**************************\n【Question】\nQuestion:\nHow many flights were there from San Diego International airport to Los Angeles International airport in the August of 2018?\nflights from refers to ORIGIN; San Diego International airport refers to Description = \'San Diego, CA: San Diego International\'; flights to refers to DEST; Los Angeles International airport refers to Description = \'Los Angeles, CA: Los Angeles International\'; in the August of 2018 refers to FL_DATE like \'2018/8%\';\n\n**************************\n【Answer】\n**Repeating the question and generating the SQL with Recursive Divide-and-Conquer.**\n\n**Question**: How many flights were there from San Diego International airport to Los Angeles International airport in the August of 2018? flights from refers to ORIGIN; San Diego International airport refers to Description = \'San Diego, CA: San Diego International\'; flights to refers to DEST; Los Angeles International airport refers to Description = \'Los Angeles, CA: Los Angeles International\'; in the August of 2018 refers to FL_DATE like \'2018/8%\';\n\n**1. Divide and Conquer:**\n\n* **Main Question:** How many flights were there from San Diego International airport to Los Angeles International airport in the August of 2018?\n   * **Analysis:** The question asks for a count of flights, which can be obtained by counting the `FL_DATE` entries in the `airlines.Airlines` table. We need to apply three filters: flights originating from San Diego International, flights destined for Los Angeles International, and flights occurring in August 2018.\n   * **Pseudo SQL:** SELECT COUNT(`FL_DATE`) FROM `{BQ_DATA_PROJECT_ID}.airlines.Airlines` WHERE <flights are in August 2018> AND <flights are from San Diego International> AND <flights are to Los Angeles International>\n\n   * **Sub-question 1:** flights are in August 2018\n       * **Analysis:** This filter can be directly applied to the `{BQ_DATA_PROJECT_ID}.airlines.Airlines` table using the `FL_DATE` column and the `LIKE` operator, as indicated by the evidence.\n       * **Pseudo SQL:** `FL_DATE` LIKE \'2018/8%\'\n\n   * **Sub-question 2:** flights are from San Diego International\n       * **Analysis:**  We need to find the airport code (`ORIGIN`) corresponding to \'San Diego, CA: San Diego International\' from the `{BQ_DATA_PROJECT_ID}.airlines.Airports` table and use it to filter the `airlines.Airlines` table. This requires joining `airlines.Airports` and `airlines.Airlines` based on `airlines.Airports`.`Code` = `airlines.Airlines`.`ORIGIN`.\n       * **Pseudo SQL:** `ORIGIN` = (SELECT `T2`.`ORIGIN` FROM `{BQ_DATA_PROJECT_ID}.airlines.Airports` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.airlines.Airlines` AS `T2` ON `T1`.`Code` = `T2`.`ORIGIN` WHERE `T1`.`Description` = \'San Diego, CA: San Diego International\')\n\n   * **Sub-question 3:** flights are to Los Angeles International\n       * **Analysis:** Similar to sub-question 2, we need to find the airport code (`DEST`) for \'Los Angeles, CA: Los Angeles International\' from the `airlines.Airports` table and use it to filter the `airlines.Airlines` table. This also requires joining `airlines.Airports` and `airlines.Airlines`, but this time on `airlines.Airports`.`Code` = `airlines.Airlines`.`DEST`.\n       * **Pseudo SQL:** `DEST` = (SELECT `T4`.`DEST` FROM `{BQ_DATA_PROJECT_ID}.airlines.Airports` AS `T3` INNER JOIN `{BQ_DATA_PROJECT_ID}.airlines.Airlines` AS `T4` ON `T3`.`Code` = `T4`.`DEST` WHERE `T3`.`Description` = \'Los Angeles, CA: Los Angeles International\')\n\n**2. Assembling SQL:**\n\n* **Sub-question 1 (flights are in August 2018):**\n   * **SQL:** `FL_DATE` LIKE \'2018/8%\'\n\n* **Sub-question 2 (flights are from San Diego International):**\n   * **SQL:** `ORIGIN` = (SELECT DISTINCT `T2`.`ORIGIN` FROM `{BQ_DATA_PROJECT_ID}.airlines.Airports` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.airlines.Airlines` AS `T2` ON `T1`.`Code` = `T2`.`ORIGIN` WHERE `T1`.`Description` = \'San Diego, CA: San Diego International\')\n\n* **Sub-question 3 (flights are to Los Angeles International):**\n   * **SQL:** `DEST` = (SELECT DISTINCT `T4`.`DEST` FROM `{BQ_DATA_PROJECT_ID}.airlines.Airports` AS `T3` INNER JOIN `{BQ_DATA_PROJECT_ID}.airlines.Airlines` AS `T4` ON `T3`.`Code` = `T4`.`DEST` WHERE `T3`.`Description` = \'Los Angeles, CA: Los Angeles International\')\n\n* **Main Question (count of flights):**\n   * **SQL:** SELECT COUNT(`FL_DATE`) FROM `{BQ_DATA_PROJECT_ID}.airlines.Airlines` WHERE `FL_DATE` LIKE \'2018/8%\' AND `ORIGIN` = (SELECT `T2`.`ORIGIN` FROM `{BQ_DATA_PROJECT_ID}.airlines.Airports` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.airlines.Airlines` AS `T2` ON `T1`.`Code` = `T2`.`ORIGIN` WHERE `T1`.`Description` = \'San Diego, CA: San Diego International\') AND `DEST` = (SELECT `T4`.`DEST` FROM `{BQ_DATA_PROJECT_ID}.airlines.Airports` AS `T3` INNER JOIN `{BQ_DATA_PROJECT_ID}.airlines.Airlines` AS `T4` ON `T3`.`Code` = `T4`.`DEST` WHERE `T3`.`Description` = \'Los Angeles, CA: Los Angeles International\')\n\n**3. Simplification and Optimization:**\n\n* The query in step 2 is already quite optimized. We are using nested queries to avoid joining the `airlines.Airports` table multiple times in the main query, which could potentially impact performance.\n\n**Final Optimized SQL Query:**\n```sql\nSELECT COUNT(FL_DATE)\n FROM `{BQ_DATA_PROJECT_ID}`.airlines.Airlines\n WHERE FL_DATE LIKE \'2018/8%\'\n AND ORIGIN = (\n   SELECT DISTINCT T2.ORIGIN\n   FROM `{BQ_DATA_PROJECT_ID}`.airlines.Airports AS T1\n   INNER JOIN `{BQ_DATA_PROJECT_ID}`.airlines.Airlines AS T2 ON T1.Code = T2.ORIGIN\n   WHERE T1.Description = \'San Diego, CA: San Diego International\' )\n AND DEST = (\n   SELECT DISTINCT T4.DEST\n   FROM `{BQ_DATA_PROJECT_ID}`.airlines.Airports AS T3\n   INNER JOIN `{BQ_DATA_PROJECT_ID}`.airlines.Airlines AS T4 ON T3.Code = T4.DEST\n   WHERE T3.Description = \'Los Angeles, CA: Los Angeles International\' )\n```\n\n===========\nExample 7\n\n**************************\n【Database Info】\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.food_inspection.businesses\n(\n       `business_id` INT64,\n       `name` STRING OPTIONS(description="the name of the eatery"),\n);\n\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.food_inspection.inspections\n(\n       `business_id` INT64 OPTIONS(description="the unique id of the business"),\n       `score` INT64 OPTIONS(description="description: the inspection score"),\n       `date` DATE,\n);\n\nCREATE TABLE `{BQ_DATA_PROJECT_ID}`.food_inspection.violations\n(\n       `business_id` INT64,\n       `date` DATE,\n);\n\n**************************\n【Question】\nQuestion:\nWhat are the names of the establishments that met all the required standards for 4 consecutive years?\nestablishment has the same meaning as business; score of 90 or more refers to score ≥ 90; year(date) = 2015; ; met all required standards for 4 consecutive years refers to COUNT(year(date)) = 4 where score = 100;\n\n**************************\n【Answer】\nRepeating the question and generating the SQL with Recursive Divide-and-Conquer.\n\n**Question**: What are the names of the establishments that met all the required standards for 4 consecutive years? establishment has the same meaning as business; score of 90 or more refers to score ≥ 90; year(date) = 2015; ; met all required standards for 4 consecutive years refers to COUNT(year(date)) = 4 where score = 100;\n\n**1. Divide and Conquer:**\n\n* **Main Question:** What are the names of the establishments that met all the required standards for 4 consecutive years?\n   * **Analysis:** We need to find the names of businesses that have a score of 100 for 4 consecutive years. The `food_inspection.businesses` table contains the `name` and the `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` table contains the `score` and `date`. We will need to join these tables and filter by score. To check for consecutive years, we\'ll need to group by business and year, then check if each group has a count of 4.\n   * **Pseudo SQL:** SELECT DISTINCT `T2`.`name` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE  <score = 100> AND <4 consecutive years>\n\n   * **Sub-question 1:** score = 100\n       * **Analysis:** This is a simple filter on the `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` table where we select rows with a `score` of 100.\n       * **Pseudo SQL:** `T1`.`score` = 100\n\n   * **Sub-question 2:** 4 consecutive years\n       * **Analysis:** This is more complex. We need to group the inspections by business and year, then check if the count for each group is 4. To get the year from the `date` column, we\'ll use the `FORMAT_DATE(\'%Y\', date)` function. We\'ll also need to use window functions to assign a rank to each year within a business, allowing us to check for consecutiveness.\n       * **Pseudo SQL:** `T2`.`name` IN (SELECT `T4`.`name` FROM (SELECT `T3`.`name`, `T3`.`years`, row_number() OVER (PARTITION BY `T3`.`name` ORDER BY `T3`.`years`) AS `rowNumber` FROM (SELECT DISTINCT `name`, FORMAT_DATE(\'%Y\', date) AS `years` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE `T1`.`score` = 100) AS `T3`) AS `T4` GROUP BY `T4`.`name`, date(`T4`.`years` || \'-01-01\', \'-\' || (`T4`.`rowNumber` - 1) || \' years\') HAVING COUNT(`T4`.`years`) = 4)\n\n       * **Sub-question 2.1:** Get distinct businesses and their inspection years where the score is 100\n           * **Analysis:** We need to join `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` and `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` tables, filter by `score` = 100, and select distinct business names and their inspection years.\n           * **Pseudo SQL:** SELECT DISTINCT `name`, FORMAT_DATE(\'%Y\', date) AS `years` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE `T1`.`score` = 100\n\n       * **Sub-question 2.2:** Assign a rank to each year within a business\n           * **Analysis:** We\'ll use the `row_number()` window function to assign a rank to each year within each business, ordered chronologically. This will help us identify consecutive years later.\n           * **Pseudo SQL:** SELECT `T3`.`name`, `T3`.`years`, row_number() OVER (PARTITION BY `T3`.`name` ORDER BY `T3`.`years`) AS `rowNumber` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE `T1`.`score` = 100` AS `T3`\n\n       * **Sub-question 2.3:** Group by business and consecutive year groups and check if the count is 4\n           * **Analysis:** We\'ll group the results by business name and a calculated date representing the start of each potential 4-year period. This date is calculated by adding (`rowNumber` - 1) years to the first day of the year extracted from the `years` column. We then filter for groups with a count of 4, indicating 4 consecutive years.\n           * **Pseudo SQL:** SELECT `T4`.`name` FROM (<previous sub-query>) AS `T4` GROUP BY `T4`.`name`, date(`T4`.`years` || \'-01-01\', \'-\' || (`T4`.`rowNumber` - 1) || \' years\') HAVING COUNT(`T4`.`years`) = 4\n\n**2. Assembling SQL:**\n\n* **Sub-question 2.1 (distinct businesses and years with score 100):**\n   * **SQL:** SELECT DISTINCT `name`, FORMAT_DATE(\'%Y\', date) AS `years` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE `T1`.`score` = 100\n\n* **Sub-question 2.2 (assign rank to each year within a business):**\n   * **SQL:** SELECT `T3`.`name`, `T3`.`years`, row_number() OVER (PARTITION BY `T3`.`name` ORDER BY `T3`.`years`) AS `rowNumber` FROM (SELECT DISTINCT `name`, FORMAT_DATE(\'%Y\', date) AS `years` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE `T1`.`score` = 100) AS `T3`\n\n* **Sub-question 2.3 (group by business and consecutive year groups):**\n   * **SQL:** SELECT `T4`.`name` FROM (SELECT `T3`.`name`, `T3`.`years`, row_number() OVER (PARTITION BY `T3`.`name` ORDER BY `T3`.`years`) AS `rowNumber` FROM (SELECT DISTINCT `name`, FORMAT_DATE(\'%Y\', date) AS `years` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE `T1`.`score` = 100) AS `T3`) AS `T4` GROUP BY `T4`.`name`, DATE_SUB(DATE(CONCAT(T4.years, \'-01-01\')), INTERVAL (T4.rowNumber - 1) YEAR)  HAVING COUNT(`T4`.`years`) = 4\n\n* **Sub-question 2 (4 consecutive years):**\n   * **SQL:** `T2`.`name` IN (SELECT `T4`.`name` FROM (SELECT `T3`.`name`, `T3`.`years`, row_number() OVER (PARTITION BY `T3`.`name` ORDER BY `T3`.`years`) AS `rowNumber` FROM (SELECT DISTINCT `name`, FORMAT_DATE(\'%Y\', date) AS `years` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE `T1`.`score` = 100) AS `T3`) AS `T4` GROUP BY `T4`.`name`, DATE_SUB(DATE(CONCAT(T4.years, \'-01-01\')), INTERVAL (T4.rowNumber - 1) YEAR)  HAVING COUNT(`T4`.`years`) = 4)\n\n* **Main Question (names of establishments):**\n   * **SQL:** SELECT DISTINCT `T2`.`name` FROM `{BQ_DATA_PROJECT_ID}.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE  `T1`.`score` = 100 AND `T2`.`name` IN (SELECT `T4`.`name` FROM (SELECT `T3`.`name`, `T3`.`years`, row_number() OVER (PARTITION BY `T3`.`name` ORDER BY `T3`.`years`) AS `rowNumber` FROM (SELECT DISTINCT `name`, FORMAT_DATE(\'%Y\', date) AS `years` FROM `{BQ_DATA_PROJECT_ID}.food_inspection.inspections` AS `T1` INNER JOIN `{BQ_DATA_PROJECT_ID}.food_inspection.businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE `T1`.`score` = 100) AS `T3`) AS `T4` GROUP BY `T4`.`name`, DATE_SUB(DATE(CONCAT(T4.years, \'-01-01\')), INTERVAL (T4.rowNumber - 1) YEAR) HAVING COUNT(`T4`.`years`) = 4)\n\n**3. Simplification and Optimization:**\n\n* The final SQL query from step 2 can be simplified by merging the nested queries into a single query with a `WITH` clause. This improves readability and potentially performance.\n\n**Final Optimized SQL Query:**\n```sql\nSELECT DISTINCT T4.name\n FROM ( SELECT T3.name, T3.years, row_number()\n OVER (PARTITION BY T3.name ORDER BY T3.years)\n AS rowNumber FROM ( SELECT DISTINCT name, FORMAT_DATE(\'%Y\', date)\n AS years FROM `{BQ_DATA_PROJECT_ID}`.food_inspection.inspections AS T1\n INNER JOIN `{BQ_DATA_PROJECT_ID}`.food_inspection.businesses AS T2 ON T1.business_id = T2.business_id\n WHERE T1.score = 100 ) AS T3 ) AS T4\n GROUP BY T4.name, DATE_SUB(DATE(CONCAT(T4.years, \'-01-01\')), INTERVAL (T4.rowNumber - 1) YEAR) HAVING COUNT(T4.years) = 4\n```\n===========\nExample 8\n\n**************************\n【Database Info】\nCREATE TABLE `bigquery-public-data.covid19_symptom_search.symptom_search_sub_region_2_daily`\n(\n  country_region_code STRING,\n  country_region STRING,\n  sub_region_1 STRING,\n  sub_region_1_code STRING,\n  sub_region_2 STRING,\n  sub_region_2_code STRING,\n  place_id STRING,\n  date DATE,\n  symptom_Abdominal_obesity FLOAT64,\n  symptom_Abdominal_pain FLOAT64,\n  symptom_Acne FLOAT64\n)\nPARTITION BY date\nCLUSTER BY country_region_code, sub_region_1_code, sub_region_2_code, sub_region_2;\n\n**************************\n【Question】\nQuestion:\nFind the day in which the symptom that occurs most frequently is headache.\n\n**************************\n【Answer】\nRepeating the question and generating the SQL with Recursive Divide-and-Conquer.\n\n**Question**: Find the day in which the symptom that occurs most frequently is headache.\n\nAnalysis: We need to determine the day (day of the week) when the frequency of searches for the symptom "headache" is the highest. This involves:\n   - Grouping the data by the day of the week.\n   - Counting the occurrences of searches for "headache."\n   - Sorting the counts in descending order and selecting the day with the highest count.\n\nPseudo SQL:\n   SELECT FORMAT_DATE(\'%A\', date) AS day, COUNT(*) AS headache_count\n   FROM `bigquery-public-data.covid19_symptom_search.symptom_search_sub_region_2_daily`\n   WHERE symptom_Headache > 0\n   GROUP BY day\n   ORDER BY headache_count DESC\n   LIMIT 1\n\nSub-question 1: Extract the day of the week from the date column.\n   - Analysis: Use the FORMAT_DATE function with the %A format specifier to extract the day name (e.g., "Monday," "Tuesday") from the date column.\n\nPseudo SQL:\n   SELECT FORMAT_DATE(\'%A\', date) AS day\n   FROM `bigquery-public-data.covid19_symptom_search.symptom_search_sub_region_2_daily`\n\nSub-question 2: Filter rows where "headache" searches occurred.\n   - Analysis: Only include rows where the symptom "headache" has a positive value (symptom_Headache > 0).\n\nPseudo SQL:\n   SELECT date\n   FROM `bigquery-public-data.covid19_symptom_search.symptom_search_sub_region_2_daily`\n   WHERE symptom_Headache > 0\n\nSub-question 3: Count the occurrences of "headache" searches grouped by day of the week.\n   - Analysis: After filtering the data for rows where symptom_Headache > 0, group the data by the day of the week and count the number of rows for each day.\n\nPseudo SQL:\n   SELECT FORMAT_DATE(\'%A\', date) AS day, COUNT(*) AS headache_count\n   FROM `bigquery-public-data.covid19_symptom_search.symptom_search_sub_region_2_daily`\n   WHERE symptom_Headache > 0\n   GROUP BY day\n\nSub-question 4: Sort the results by the count in descending order and get the top day.\n   - Analysis: Use the ORDER BY clause to sort by the count of "headache" searches in descending order. Limit the result to 1 to get the top day.\n\nPseudo SQL:\n   SELECT FORMAT_DATE(\'%A\', date) AS day, COUNT(*) AS headache_count\n   FROM `bigquery-public-data.covid19_symptom_search.symptom_search_sub_region_2_daily`\n   WHERE symptom_Headache > 0\n   GROUP BY day\n   ORDER BY headache_count DESC\n   LIMIT 1\n\nAssembling SQL\n   - Combining all sub-questions into the final query:\n\n**Final Optimized SQL Query:**\n```sql\nSELECT\n  FORMAT_DATE(\'%A\', PARSE_DATE(\'%Y-%m-%d\', date)) AS day,\n  COUNT(*) AS headache_count\nFROM\n  `bigquery-public-data`.`covid19_symptom_search`.`symptom_search_country_daily`\nGROUP BY\n  day\nORDER BY\n  headache_count DESC\nLIMIT 1;\n```\n\nNow is the real question, following the instruction and examples, generate the GoogleSQL with Recursive Divide-and-Conquer approach.\nFollow all steps from the strategy. When you get to the final query, output the query string ONLY in the format ```sql ... ```. Make sure you only output one single query.\nTable names always should be exactly the same as the table names mentioned in the database schema, for example, `{BQ_DATA_PROJECT_ID}.airlines.Airlines` instead of `Airlines`.\n\n**************************\n【Table creation statements】\n{SCHEMA}\n\n**************************\n【Question】\nQuestion:\n{QUESTION}\n\n**************************\n【Answer】\nRepeating the question and generating the SQL with Recursive Divide-and-Conquer.\n'